# V1t CTF 2025

This ctf is for me to take slowly, and learn as much as I can, not replying on gpt as much as I do before. Lesgo!

## Rev

### Snail Delivery

Description: Enter your flag and the snail will deliver it to headquarters for verification. But be careful - it moves slowly!

```bash
$ file snail
snail: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=becf67c2c746e203cd1c1d8ea4cf3ab7e0c2ad1c, for GNU/Linux 3.2.0, not stripped
```

```
$ ./snail
Enter the flag: test
The snail is sending the flag to headquarters to check...
___@>^C
```

after entering test flag (i dont even know the format yet) it printed a snail, but taking too long to validate it. So maybe I can patch the binary to remove the snail?

```
$ strings snail
/lib64/ld-linux-x86-64.so.2
...
Enter the flag:
The snail is sending the flag to headquarters to check...
We have received it brother...
We check it, it was correct bro: %s
Wut is ts
;*3$"
GCC: (Debian 14.2.0-8) 14.2.0
...
```

strings the file show our end goal if we got the correct flag. straight to IDA we go

For this challenge there are only one function

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v4; // rax
  _QWORD v5[3]; // [rsp+0h] [rbp-170h]
  _BYTE v6[15]; // [rsp+18h] [rbp-158h]
  int v7; // [rsp+27h] [rbp-149h]
  __int16 v8; // [rsp+2Bh] [rbp-145h]
  _BYTE v9[3]; // [rsp+2Dh] [rbp-143h]
  char s[264]; // [rsp+30h] [rbp-140h] BYREF
  void *ptr; // [rsp+138h] [rbp-38h]
  size_t v12; // [rsp+140h] [rbp-30h]
  size_t m; // [rsp+148h] [rbp-28h]
  int v14; // [rsp+154h] [rbp-1Ch]
  size_t k; // [rsp+158h] [rbp-18h]
  int j; // [rsp+164h] [rbp-Ch]
  int i; // [rsp+168h] [rbp-8h]
  unsigned int seconds; // [rsp+16Ch] [rbp-4h]

  printf("Enter the flag: ");
  if ( !fgets(s, 256, stdin) )
    return 1;
  s[strcspn(s, "\n")] = 0;
  puts("The snail is sending the flag to headquarters to check...");
  seconds = 1;
  for ( i = 0; i <= 15; ++i )
  {
    seconds *= 2;
    putchar(13);
    for ( j = 0; j < i; ++j )
      putchar(95);
    printf("@>");
    fflush(_bss_start);
    sleep(seconds);
  }
  v9[0] = BYTE2(seconds);
  v9[1] = BYTE1(seconds);
  v9[2] = seconds;
  v12 = strlen(s);
  ptr = malloc(v12 + 1);
  if ( !ptr )
    return 1;
  for ( k = 0LL; k < v12; ++k )
    *((_BYTE *)ptr + k) = v9[k % 3] ^ s[k];
  puts("\nWe have received it brother...");
  *((_BYTE *)ptr + v12) = 0;
  v7 = -1418181358;
  v8 = -4147;
  v5[0] = 0x2C2781BED10C7465LL;
  v5[1] = 0x990E747FDCA9F514LL;
  v5[2] = 0xB0BA9A14364C96BFLL;
  *(_QWORD *)v6 = 0x7521DBFB99272327LL;
  *(_QWORD *)&v6[7] = 0x38718EFF9C4F75LL;
  v14 = 1;
  for ( m = 0LL; ; ++m )
  {
    v4 = strlen(s);
    if ( m >= v4 )
      break;
    if ( (*((unsigned __int8 *)&v7 + m % 6) ^ s[m]) != *((unsigned __int8 *)v5 + m) )
    {
      v14 = 0;
      break;
    }
  }
  if ( v14 )
    printf("We check it, it was correct bro: %s\n", (const char *)ptr);
  else
    printf("Wut is ts");
  free(ptr);
  return 0;
}
```

What do I know about this? dont really know. but lets learn

* ```
  printf("Enter the flag: ");
  fgets(s, 256, stdin);
  s[strcspn(s, "\n")] = 0;
  ```
* our input is stored in s. Max is 255. Deletes any trailing \n
* ```
  seconds = 1;
    for ( i = 0; i <= 15; ++i )
    {
      seconds *= 2;
      putchar(13);
      for ( j = 0; j < i; ++j )
        putchar(95);
      printf("@>");
      fflush(_bss_start);
      sleep(seconds);
    }
  ```
* This is the snail part. second iterated by 16 times. seconds \*= 2 is second = second \* 2. so its power of 2. 2 power of 16 is 65536. Total sleep = 2+4+...+65536 = 131,070 seconds (\~36.4 hours).
* ```
  v9[0] = BYTE2(seconds);
    v9[1] = BYTE1(seconds);
    v9[2] = seconds;
  ```
* but next part taking in the final second which is 65536 as input. 65536 in hex is 0x00010000 (this binary is 64bit). So now we want to know what will be store in v9 array. what is BYTE2, BYTE1?

<table><thead><tr><th width="103">BYTE</th><th width="94">BYTE7</th><th width="97">BYTE6</th><th width="100">BYTE5</th><th width="99">BYTE4</th><th width="95">BYTE3</th><th width="95">BYTE2</th><th width="97">BYTE1</th><th>BYTE0</th></tr></thead><tbody><tr><td>v9</td><td>[7]</td><td>[6]</td><td>[5]</td><td>[4]</td><td>[3]</td><td>[2]</td><td>[1]</td><td>[0]</td></tr><tr><td>65536</td><td>00</td><td>00</td><td>00</td><td>00</td><td>00</td><td>01</td><td>00</td><td>00</td></tr></tbody></table>

Hope you can make sense of the table.

* {% code lineNumbers="true" %}
  ```
    v12 = strlen(s);
    ptr = malloc(v12 + 1);
    if ( !ptr )
      return 1;
    for ( k = 0LL; k < v12; ++k )
      *((_BYTE *)ptr + k) = v9[k % 3] ^ s[k];
    puts("\nWe have received it brother...");
    *((_BYTE *)ptr + v12) = 0;
  ```
  {% endcode %}
* taking strings length of s into v12. line 5 is allocating a writable buffer for v12 and null terminator (thats why +1). if it fail, it bail out (line 6 and 7). then loop over each byte in s. so the ptr is just cpu thingy. for each k, every 3 multi, like 0, 3, 6, 9, will be xored with 0x01. the other with 0x00 because v9 array just have 3 number v9 = { 0x01, 0x00, 0x00 }. so&#x20;
  * k=0 → XOR with `v9[0]` (0x01)
  * k=1 → XOR with `v9[1]` (0x00)
  * k=2 → XOR with `v9[2]` (0x00)
  * k=3 → back to `v9[0]` (0x01)
* xored with 0x00 means unchanged
* ```
  v7 = -1418181358;   // 32-bit
  v8 = -4147;         // 16-bit
  //or
  //v7 = 0xAB784512;
  //v8 = 0xEFCD;
  // Together (little-endian memory): 6 bytes = [0x12, 0x45, 0x78, 0xAB, 0xCD, 0xEF]

  v5[0] = 0x2C2781BED10C7465;
  v5[1] = 0x990E747FDCA9F514;
  v5[2] = 0xB0BA9A14364C96BF;
  // v5 is 3 QWORDs => 24 bytes laid out in memory (little-endian).
  *(_QWORD *)v6 = 0x7521DBFB99272327LL;
  *(_QWORD *)&v6[7] = 0x38718EFF9C4F75LL;
  ```
* setup the variable
* ```
  v14 = 1;
    for ( m = 0LL; ; ++m )
    {
      v4 = strlen(s);
      if ( m >= v4 )
        break;
      if ( (*((unsigned __int8 *)&v7 + m % 6) ^ s[m]) != *((unsigned __int8 *)v5 + m) )
      {
        v14 = 0;
        break;
      }
    }
  ```
* this is the check for flag.
* Treat `v7||v8` as a 6-byte repeating key:\
  key = `[0x12, 0x45, 0x78, 0xAB, 0xCD, 0xEF]`
* Treat `v5` as a 24-byte target sequence.
*   For each position `m`, they require:

    ```
    key[m % 6] ^ s[m]  ==  v5_bytes[m]
    ⇒ s[m] == key[m % 6] ^ v5_bytes[m]
    ```
* So the **correct flag** `s` is simply the XOR of that 6-byte key repeated with the 24 bytes stored in `v5`.
* Because `v5` is only 24 bytes, a “safe” correct length is ≤ 24 bytes (the code would otherwise read beyond those 24 bytes).
* so... it like
* ```
  read s
  // (sleep animation that just wastes time)

  key3 = [0x01, 0x00, 0x00]  // from seconds=65536
  ptr = xor_every_3rd_byte_with_1(s)  // positions 0,3,6,...

  key6 = bytes_of(v7 little-endian) + first_two_bytes_of(v8)  // 12 45 78 AB CD EF
  expected = bytes_of(v5[0]) || bytes_of(v5[1]) || bytes_of(v5[2])  // 24 bytes

  for m in 0..len(s)-1:
      if ( (key6[m % 6] ^ s[m]) != expected[m] ):
          fail

  // success:
  print ptr  // not s

  ```

Bear with me now... i starting to not understand. but heres the POC. (gpt because i dont know how to write code)

```python
#!/usr/bin/env python3
import struct

def le_qword(x): return struct.pack("<Q", x)
def le_i32(x):   return struct.pack("<i", x)
def le_i16(x):   return struct.pack("<h", x)

# ---- Constants from the binary ----
v7 = -1418181358          # int32
v8 = -4147                # int16

v5 = [
    0x2C2781BED10C7465,
    0x990E747FDCA9F514,
    0xB0BA9A14364C96BF,
]

# v6 is 15 bytes, written via two QWORD stores (little-endian)
v6 = bytearray(15)
v6[:8]    = le_qword(0x7521DBFB99272327)
v6[7:15]  = le_qword(0x038718EFF9C4F75)[:8]  # high byte is 0x00, keep 8 bytes but we only need 8@7..14

# Target byte stream that the check compares against: v5 (24 bytes) + v6 (15 bytes) = 39 bytes
target = b''.join(le_qword(x) for x in v5) + bytes(v6)

# 6-byte repeating key is bytes of v7 (4) followed by v8 (2), little-endian
key6 = le_i32(v7) + le_i16(v8)  # b'\x12\x45\x78\xab\xcd\xef'

# The program checks:  (key6[m%6] ^ s[m]) == target[m]  =>  s[m] = key6[m%6] ^ target[m]
s = bytes(t ^ key6[i % 6] for i, t in enumerate(target))

# After validation, it prints s XOR [BYTE2, BYTE1, BYTE0] of seconds (seconds ends at 2^16 => [0x01,0x00,0x00] repeating)
print_xor = bytes((1,0,0))
printed = bytes(b ^ print_xor[i % 3] for i, b in enumerate(s))

# Nice output
print("== Solver for the snail binary ==")
print("Enter this when asked for the flag:")
print(s.decode('latin1'))
print()
print("The program will print:")
print(printed.decode('latin1'))
print()
# If you just want the actual flag inside braces (ignoring a trailing 'x'):
import re
m = re.search(r'([A-Za-z0-9_]+{[^}]+})', printed.decode('latin1'))
if m:
    print("Extracted flag:", m.group(1))


```

```
== Solver for the snail binary ==
Enter this when asked for the flag:
w1tzsn5il^d3m1v2ry^sl1w_5f_26430772ac}x

The program will print:
v1t{sn4il_d3l1v3ry_sl0w_4f_36420762ab}x

Extracted flag: v1t{sn4il_d3l1v3ry_sl0w_4f_36420762ab}
```

### Optimus

description: uu ee ac ac

```bash
$ file optimus
optimus: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bef22db314be57287a814871ff6b1e52060d202a, for GNU/Linux 3.2.0, not stripped
```

```bash
$ ./optimus
Input flag: test
WRONG FLAG
```

```
$ strings optimus
...
0ov13tc{9zxpdr6na13m6a73534th5a}
Input flag:
WRONG FLAG
FLAG OK QUACK
...
```

two function this time

```
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[268]; // [rsp+0h] [rbp-130h] BYREF
  int v5; // [rsp+10Ch] [rbp-24h]
  char *s; // [rsp+110h] [rbp-20h]
  unsigned int k; // [rsp+118h] [rbp-18h]
  int v8; // [rsp+11Ch] [rbp-14h]
  size_t j; // [rsp+120h] [rbp-10h]
  unsigned int i; // [rsp+128h] [rbp-8h]
  int v11; // [rsp+12Ch] [rbp-4h]

  s = "0ov13tc{9zxpdr6na13m6a73534th5a}";
  v5 = strlen("0ov13tc{9zxpdr6na13m6a73534th5a}");
  v11 = 0;
  for ( i = 0; (int)i < v5; ++i )
  {
    if ( (unsigned __int8)is_prime(i) )
      ++v11;
  }
  printf("Input flag: ");
  if ( !fgets(v4, 256, _bss_start) )
    return 2;
  for ( j = strlen(v4); j && (v4[j - 1] == 10 || v4[j - 1] == 13); j = strlen(v4) )
    v4[j - 1] = 0;
  if ( v11 == (_DWORD)j )
  {
    v8 = 0;
    for ( k = 0; (int)k < v5; ++k )
    {
      if ( (unsigned __int8)is_prime(k) == 1 )
      {
        if ( v4[v8] != s[k] )
          goto LABEL_14;
        ++v8;
      }
    }
    puts("FLAG OK QUACK ");
    return 0;
  }
  else
  {
LABEL_14:
    puts("WRONG FLAG ");
    return 1;
  }
}
```

```
__int64 __fastcall is_prime(int a1)
{
  int i; // [rsp+10h] [rbp-4h]

  if ( a1 <= 1 )
    return 0LL;
  if ( a1 == 2 )
    return 1LL;
  if ( (a1 & 1) == 0 )
    return 0LL;
  for ( i = 3; a1 >= i * i; i += 2 )
  {
    if ( !(a1 % i) )
      return 0LL;
  }
  return 1LL;
}
```

basically, The program wants you to type the characters of the hard-coded string\
`"0ov13tc{9zxpdr6na13m6a73534th5a}"` **at prime indices only** (0-based).

```c
s = "0ov13tc{9zxpdr6na13m6a73534th5a}";
v5 = strlen(s); // v5 == 32
```

The string length is 32. Valid indices are `0..31`.

```c
v11 = 0;
for (i = 0; i < v5; ++i)
  if (is_prime(i))
    ++v11;
```

This counts primes in `[0,31]` with the provided `is_prime`:

* Returns 0 (false) for `n <= 1`
* True for `2`
* Rejects even numbers > 2
* Checks odd divisors up to `sqrt(n)`

**Prime indices in 0..31:**\
`2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31` → **11 primes**, so `v11 = 11`.

```c
printf("Input flag: ");
fgets(v4, 256, _bss_start);          // read a line
// strip trailing '\n'/'\r'
if (v11 != strlen(v4)) goto WRONG;
```

So your input must be length **11** (after trimming newline).

```c
v8 = 0;
for (k = 0; k < v5; ++k) {
  if (is_prime(k)) {
    if (v4[v8] != s[k]) goto WRONG;
    ++v8;
  }
}
puts("FLAG OK QUACK");
```

They walk through all indices `k`; whenever `k` is prime, they compare the next character of your input (`v4[v8]`) with `s[k]`. If **all** match, you win.

| index | char  |
| ----: | ----- |
|     2 | **v** |
|     3 | **1** |
|     5 | **t** |
|     7 | **{** |
|    11 | **p** |
|    13 | **r** |
|    17 | **1** |
|    19 | **m** |
|    23 | **3** |
|    29 | **5** |
|    31 | **}** |

v1t{pr1m35}

Why 0-based indices matter?C strings are 0-indexed. Prime indices start at **2**, not **1**, and index 31 (the last char) is included because 31 is prime and the string length is 32.

### Bad Reverser

description: I always beat myself up because I'm bad at reverse engineering :<

```bash
$ file chal_goon
chal_goon: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=23b83f07f336a12096c938833ea35952d69735fa, for GNU/Linux 3.2.0, stripped

$ ./chal_goon
Enter flag: test
Wrong!
```

this time the binary is stripped

```
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  int *v3; // rax
  int *v4; // rbx
  __int64 v5; // rax
  unsigned __int8 v6; // cl
  int v7; // esi
  __int64 v8; // rdx
  int v9; // eax
  char v10; // dl
  int v11; // edi
  __int64 v12; // rdx
  __int64 v13; // rdi
  int i; // [rsp+4h] [rbp-144h]
  __int64 v16; // [rsp+8h] [rbp-140h]
  timespec tp; // [rsp+10h] [rbp-138h] BYREF
  struct timespec v18; // [rsp+20h] [rbp-128h] BYREF
  _OWORD v19[4]; // [rsp+30h] [rbp-118h] BYREF
  __int64 v20; // [rsp+70h] [rbp-D8h]
  _BYTE v21[48]; // [rsp+80h] [rbp-C8h]
  char s[136]; // [rsp+B0h] [rbp-98h] BYREF
  unsigned __int64 v23; // [rsp+138h] [rbp-10h]

  v23 = __readfsqword(0x28u);
  __printf_chk(2LL, "Enter flag: ", a3);
  memset(s, 0, 0x80uLL);
  if ( !fgets(s, 128, stdin) )
    goto LABEL_16;
  s[strcspn(s, "\n")] = 0;
  if ( strlen(s) != 11 )
    goto LABEL_16;
  if ( *(_DWORD *)s != 2071212406 )
    goto LABEL_16;
  v3 = __errno_location();
  *v3 = 0;
  v4 = v3;
  if ( ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL) == -1 )
  {
    if ( *v4 )
      goto LABEL_16;
  }
  clock_gettime(1, &tp);
  v16 = 0LL;
  for ( i = 0; i <= 499999; v16 += i++ )
    ;
  clock_gettime(1, &v18);
  if ( v18.tv_nsec + 1000000000 * (v18.tv_sec - tp.tv_sec) - tp.tv_nsec > 500000000 )
    goto LABEL_16;
  signal(5, handler);
  v5 = 0LL;
  v6 = (s[0] + 7) ^ 0x5A;
  do
  {
    v21[v5] = v6 ^ byte_2040[v5] ^ 0xAA;
    ++v5;
  }
  while ( v5 != 41 );
  v20 = 0LL;
  v7 = 0;
  v8 = 0LL;
  v9 = 0;
  memset(v19, 0, sizeof(v19));
  while ( 1 )
  {
    v10 = v21[v8];
    v11 = v9 + 1;
    if ( v10 != 1 )
      break;
    v12 = v11;
    if ( v9 == 40 || v7 > 15 )
      goto LABEL_16;
    v13 = v7;
    v9 += 2;
    ++v7;
    *((_DWORD *)v19 + v13) = (unsigned __int8)v21[v12];
LABEL_20:
    v8 = v9;
    if ( v9 > 40 )
      goto LABEL_16;
  }
  if ( v10 == 2 )
  {
    if ( v7 <= 0 )
      goto LABEL_16;
    *((_DWORD *)v19 + v7 - 1) ^= v6;
    goto LABEL_24;
  }
  if ( v10 == 3 )
  {
    if ( v9 == 40 )
      goto LABEL_16;
    if ( v7 <= 0 )
      goto LABEL_16;
    --v7;
    v9 += 2;
    if ( s[(unsigned __int8)v21[v11] + 3] != *((unsigned __int8 *)v19 + 4 * v7) )
      goto LABEL_16;
    goto LABEL_20;
  }
  if ( v10 != -1 )
  {
    if ( v10 != -18 )
      goto LABEL_16;
LABEL_24:
    ++v9;
    goto LABEL_20;
  }
  if ( dword_401C )
LABEL_16:
    sub_1570();
  puts("Correct quack!");
  return 0LL;
}
```

```
void __noreturn sub_1570()
{
  puts("Wrong!");
  exit(1);
}
```

the program first enforces the prefix `"v1t{"` and length 11, then runs a tiny bytecode VM whose program is derived from the `.rodata` bytes XORed with a key computed from the first character. That VM pushes constants, XORs them with the same key, and compares them to positions in your input. Solving those constraints forces the remaining characters to be `my_b4D}` after the initial `v1t{`

* Reads a line into `s`, strips newline.
* Enforces `strlen(s) == 11`.
* Enforces `*(_DWORD*)s == 2071212406`.
  * Little-endian: `2071212406 = 0x7B743176`, i.e. bytes `76 31 74 7B` → `"v1t{"`.
  * So `s` must start with `"v1t{"`.
* Anti-debugger: `ptrace(PTRACE_TRACEME, …)`; if it fails due to a real tracer, it bails.
* Anti-timing: spins and checks the operation took ≤ 0.5s; otherwise bails.
* Installs a signal handler (irrelevant to solving).
* **Core check**: decodes a 41-byte “program” into `v21[]`, then interprets it with a tiny stack VM that validates the rest of your input.

If anything fails → `Wrong!`. If all passes → `Correct quack!`.



```c
v6 = (s[0] + 7) ^ 0x5A;
for v5 in 0..40:
    v21[v5] = v6 ^ byte_2040[v5] ^ 0xAA;
```

* With `s[0]='v' (0x76)`:\
  `v6 = (0x76 + 7) ^ 0x5A = 0x7D ^ 0x5A = 0x27 (39)`.
* Since `a ^ b ^ c = a ^ (b ^ c)`, this is just a fixed XOR against `byte_2040`:
  * `v21[i] = byte_2040[i] ^ (0x27 ^ 0xAA) = byte_2040[i] ^ 0x8D`.

So you can precompute the program: `v21 = byte_2040 XOR 0x8D`.



The interpreter walks `v21` with an instruction pointer `v9` and a stack of at most 16 dwords (top tracked by `v7`). Opcodes are one byte; some are followed by an 8-bit immediate.

* `0x01` (**PUSH imm8**):\
  Push the next byte (imm8) on the stack. `v9 += 2`.
* `0x02` (**XORTOP**):\
  XOR the top of the stack with `v6` (which we computed as `0x27`). `v9 += 1`.
* `0x03` (**CMPPOP imm8**):\
  Pop the stack top `T`. Compare `T` (as a byte) to `s[imm8 + 3]`. If not equal → fail. `v9 += 2`.
* `0xEE` (**NOP**): `v9 += 1`.
* `0xFF` (**END**): Finish. (If `dword_401C` were nonzero it would fail, but in normal runs it’s zero.)

Everything else → immediate fail.

**Observation:** every check compares a computed byte against `s[imm + 3]`. That means the VM verifies characters starting at `s[3]` (right after the enforced `"v1t"`).



Compute `v21 = byte_2040 ^ 0x8D` (41 bytes). Interpreting it yields this sequence:

```
PUSH 0x5C;  XOR; CMP s[3]   == 0x7B ('{')
PUSH 0x4A;  XOR; CMP s[4]   == 'm'
PUSH 0x5E;  XOR; CMP s[5]   == 'y'
PUSH 0x78;  XOR; CMP s[6]   == '_'
PUSH 0x45;  XOR; CMP s[7]   == 'b'
PUSH 0x13;  XOR; CMP s[8]   == '4'
PUSH 0x63;  XOR; CMP s[9]   == 'D'
PUSH 0x5A;  XOR; CMP s[10]  == '}'
END
```

Why those results?

* Each `PUSH imm` followed by `XOR` turns the pushed value into `imm ^ v6`.
* With `v6 = 0x27`, the VM is effectively requiring:
  * `s[3] == 0x5C ^ 0x27 = 0x7B ('{')`
  * `s[4] == 0x4A ^ 0x27 = 0x6D ('m')`
  * `s[5] == 0x5E ^ 0x27 = 0x79 ('y')`
  * `s[6] == 0x78 ^ 0x27 = 0x5F ('_')`
  * `s[7] == 0x45 ^ 0x27 = 0x62 ('b')`
  * `s[8] == 0x13 ^ 0x27 = 0x34 ('4')`
  * `s[9] == 0x63 ^ 0x27 = 0x44 ('D')`
  * `s[10] == 0x5A ^ 0x27 = 0x7D ('}')`

```
s = "v1t{my_b4D}"
```
